#include <cstdio>
#include <vector>

int main() {
    int n;
    scanf("%d", &n);

    std::vector<int> inv(n, 0);

    for (int &v : inv) {
        scanf("%d", &v);
    }

    std::vector<int> avail;

    for (int i = 0; i < n; i++) {
        avail.push_back(i + 1);
    }

    std::vector<int> perm(n, 0);

    for (int i = n - 1; i >= 0; i--) {
        int idx = avail.size() - 1 - inv[i];
        perm[i] = avail[idx];
        avail.erase(avail.begin() + idx);
    }

    for (int v : perm) {
        printf("%d ", v);
    }

    return 0;
}

/*
2    3    1
p[0] p[1] p[2]

phi[0] = 0 т.к. слева от 0 нет элементов
phi[1] = 0 т.к. слева от p[1] = 3 нет элементов больше чем 3
phi[2] = 2 т.к. слева от p[2] = 1 есть 2 и 3 элементы больше чем 1


0 1 0 0 3 0
3 1 4 5 2 6
0 на конце таблицы инверсий дает максимальное число 6 на данной позиции в перестановке
3 на позиции 4 таблицы инверсий дает число 2 на данной позиции в перестановке, потому что 3 самых больших числа пропускам (5, 4, 3) и берем следующее
0 на позиции 3 таблицы инверсий дает число 5 на данной позиции в перестановке, потому что это самое большое из неиспользованных чисел
0 на позиции 2 таблицы инверсий дает число 4 на данной позиции в перестановке, потому что это самое большое из неиспользованных чисел
1 на позиции 1 таблицы инверсий дает число 1 на данной позиции в перестановке, потому что 1 самое большое свободное число пропускаем (3) и берем следующее свободное 1
0 на позиции 0 таблицы инверсий дает число 3 на данной позиции в перестановке, потому что это самое большое из неиспользованных чисел
*/
